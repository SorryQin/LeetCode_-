## 242.有效的字母异位词
这道题目难度不大，但是有一个**容易出错**的地方：**char和int**在混合计算时，要注意 **‘’** 的使用  
下面是错误示范，这里的 'x' 应该替换为循环变量 char x，这样才能根据字符串中的实际字符来更新计数
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int map[26] = {0};
        for (char x: s) {
			map['x' - 'a']++;
        }
		for (char x: t) {
            map['x' - 'a']--;
        }
        for (int i = 0; i < 26; ++i) {
            if (map[i] != 0) {
                return false;
            }
        }

        return true;
    }
};
```
完整的正确代码如下：
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size() != t.size()) return false; // 先检查长度是否相等

        int map[26] = {0};
        for (char x: s) {
            map[x - 'a']++; // 根据字符x更新计数
        }
        for (char x: t) {
            map[x - 'a']--; // 根据字符x更新计数
        }
        for (int i = 0; i < 26; ++i) {
            if (map[i] != 0) {
                return false; // 如果有任何一个字符的计数不为0，则不是字谜
            }
        }

        return true; // 所有字符计数都为0，是字谜
    }
};
```
## 349.两个数组的交集
这道题主要是熟悉一下**unordered_set**的应用，set可以直接进行去重  
除此之外，还可以通过最后返回数组的语法，更加深刻地了解c++的语法
```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1;
        unordered_set<int> set2{nums1.begin(), nums1.end()};
        for (int num: nums2) {
            if (set2.find(num) != set2.end()) {
                set1.insert(num);
            }
        }

        return vector<int> {set1.begin(), set1.end()}; 
    }
};
```

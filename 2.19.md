## 344.反转字符串
这道题目比较简单，只需要**两个指针**分别从**首尾**指向需要交换的字符即可，每次交换之后再递增或递减，知道两个指针**相遇**
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        // 思路是前后两个指针，首尾交换字符
        int left = 0;
        int right = s.size() - 1;
        char tmp;

        while (left < right) {
            tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            left++;
            right--;
        }
    }
};
```
代码随想录给出的解法调用了**swap函数**，也可以通过简单几行代码实现功能，但是实现的底层思路和我上面手打的代码是一样的，解法如下：
```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
```
## 反转字符串II
这道题目看着简单，实际上还是有点东西的，比如我写的另外一个辅助函数reverse，刚开始我在传递值时没加 **&** ，也就代表传递的是值，无法对原字符串进行修改  
字符串传递方式：在reverse函数中，字符串是按值传递的，这意味着函数内部对字符串的修改不会影响原始字符串。你需要通过引用传递字符串
```c++
    // 我原本的reverse函数
    void reverse(string s, int left, int right) {
        while (left < right) {
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            ++left;
            --right;
        }
    }

    // 修改后的reverse函数
    // 添加了&，通过引用传递字符串，在外部进行修改
    void reverse(string& s, int left, int right) {
    ......
    }
```
下面是完整的解法，能通过测试用例，但是在提交时，会有几个无法通过：
```c++
class Solution {
public:
    void reverse(string& s, int left, int right) {
        while (left < right) {
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            ++left;
            --right;
        }
    }

    string reverseStr(string s, int k) {
        int n = 0; // 2k的轮次
        int len = s.size();
        while (len > 2 * k) {
            reverse(s, n * 2 * k, n * 2 * k + k - 1);
            len -= 2 * k;
            n++;
        }

        if (len < k) {
            reverse(s, n * 2 * k, len - 1);
        }
        if (len >= k) {
            reverse(s, n * 2 * k, n * 2 * k + k - 1);
        }
        return s;
    }
};
```

## 454.四数相加
这道题目其实还算简单，只需要计算满足条件的个数就行，我刚开始以为需要输出每一组满足条件的数组值  
只需要两两一组，再进行匹配就能实现，实现代码如下：
```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> map;
        for (int a: nums1) {
            for (int b: nums2) {
                ++map[a + b];
            }
        }

        int count = 0;

        for (int c: nums3) {
            for (int d: nums4) {
                count += map[-c - d];        
            }
        }

        return count;
    }
};
```
代码存在可以优化的地方，在计算nums3和nums4的和时，加入一个判断，虽然我没加判断，leetcode提交也通过了
```c++
        // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                // 加入判断
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
```
## 383.赎金信
这道题目也没有很大的难度，依旧是对于**map**的使用，**key**为**char**，**val**为出现的**次数**  
下附本大帅第一次就通过的题解：
```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int> map;
        for (char c: magazine) {
            ++map[c];
        }

        for (char c: ransomNote) {
            if (map.find(c) != map.end()) {
                if (map[c]) {
                    map[c]--;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
};
```
其实在本题的情况下，使用map的**空间消耗**要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！**数据量大**的话就能体现出来差别了。 所以**数组**更加简单直接有效:
```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        //add
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        for (int i = 0; i < magazine.length(); i++) {
            // 通过record数据记录 magazine里各个字符出现次数
            record[magazine[i]-'a'] ++;
        }
        for (int j = 0; j < ransomNote.length(); j++) {
            // 遍历ransomNote，在record里对应的字符个数做--操作
            record[ransomNote[j]-'a']--;
            // 如果小于零说明ransomNote里出现的字符，magazine没有
            if(record[ransomNote[j]-'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```
换成数组之后，leetcode的运行时间直接从7ms跳到了0ms，真无敌了
## 15.三数之和
哈希表法
```c++
class Solution {
public:
    // 在一个数组中找到3个数形成的三元组，它们的和为0，不能重复使用（三数下标互不相同），且三元组不能重复。
    // b（存储）== 0-(a+c)（检索）
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        
        for (int i = 0; i < nums.size(); i++) {
            // 如果a是正数，a<b<c，不可能形成和为0的三元组
            if (nums[i] > 0)
                break;
            
            // [a, a, ...] 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            
            // 这个set的作用是存储b
            unordered_set<int> set;
            
            for (int k = i + 1; k < nums.size(); k++) {
                // 去重b=c时的b和c
                if (k > i + 2 && nums[k] == nums[k - 1] && nums[k - 1] == nums[k - 2])
                    continue;
                
                // a+b+c=0 <=> b=0-(a+c)
                int target = 0 - (nums[i] + nums[k]);
                if (set.find(target) != set.end()) {
                    result.push_back({nums[i], target, nums[k]});   // nums[k]成为c
                    set.erase(target);
                }
                else {
                    set.insert(nums[k]);                            // nums[k]成为b
                }
            }
        }

        return result;
    }
};
```
